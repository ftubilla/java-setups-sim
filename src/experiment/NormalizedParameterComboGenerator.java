package experiment;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.apache.log4j.Logger;
import org.codehaus.jackson.annotate.JsonProperty;

import util.Node;

/**
 * A class for generating parameter combinations for the items. All combinations
 * are assumed to sum up to 1, and thus only the values for N-1 of the items need
 * to be given (any item may be excluded). Values are multiplied by the normalization
 * constant. 
 * Permutations of the items can be ignored, as well as combinations that lead to 
 * negative numbers.
 * 
 * @author ftubilla
 */
public class NormalizedParameterComboGenerator implements IParameterComboGenerator {
	
	private static Logger logger = Logger.getLogger(NormalizedParameterComboGenerator.class);

	@SuppressWarnings("unused")
	private boolean debug = logger.isDebugEnabled();
	private boolean trace = logger.isTraceEnabled();
	
	@JsonProperty private List<ItemParamValues> itemValuesList;
	@JsonProperty private double normConstant;	
	@JsonProperty private boolean ignorePermutations;
	@JsonProperty private boolean ignoreNegative;
	
	private List<ParameterCombo> parameterCombos;
	private boolean isGenerated = false;
		
	/* (non-Javadoc)
	 * @see experiment.IParameterComboGenerator#generate(int)
	 */
	@Override
	public void generate(int numItems) {
		
		assert itemValuesList.size() == numItems -1 : "You need to give values for N-1 of the N items";
		
		//Set of items with values. The missing items will have value generated by taking 1 - sum
		Set<Integer> itemsWithNoData = new HashSet<Integer>(numItems);
		for (int i=0; i<numItems; i++){
			itemsWithNoData.add(i);
		}
		
		ComboGenerator<ItemValue> comboGenerator = new ComboGenerator<ItemValue>();
		
		//Read the list of values for each item and add to the combo generator
		for (ItemParamValues itemValues : itemValuesList) {				
			itemsWithNoData.remove(itemValues.getItem());
			List<ItemValue> setOfValues = new ArrayList<ItemValue>();
			for (Double value : itemValues.getDoubles()){
				setOfValues.add(new ItemValue(itemValues.getItem(), value));
			}
			comboGenerator.addSet(setOfValues);
		}

		assert itemsWithNoData.size()==1 : "Check that you have values for each but one of the items!";
		int missingItem = itemsWithNoData.iterator().next();
		if (trace){
			logger.trace("Param values for item " + missingItem + " will be given by taking 1 minus the sum of the values for the other items");
		}
		
		
		//Generate the combos
		parameterCombos = new ArrayList<ParameterCombo>();
		for (Combo<ItemValue> combo : comboGenerator.generateCombos()){
			
			ParameterCombo paramCombo = new ParameterCombo(numItems);
			double sum=0.0;
			for(ItemValue itemValue : combo.getValues()){				
				paramCombo.set(itemValue.item, normConstant*itemValue.value);
				sum+=itemValue.value;				
			}
			paramCombo.set(missingItem, normConstant*(1-sum));
			
			boolean addCombo = true;
			if (ignoreNegative && paramCombo.hasNegativeValues()){
				addCombo = false;
				if (trace){logger.trace("Ignoring combination " + paramCombo + " due to negative values");}
			} 
			if (ignorePermutations){
				for (ParameterCombo existingCombo : parameterCombos){
					if (paramCombo.isAPermutationOf(existingCombo)){
						addCombo = false;
						if(trace){logger.trace("Ignoring combo " + paramCombo + " because it is a permutations of an existing comnbo");}
						break;
					}
				}
			}
			if (addCombo){
				parameterCombos.add(paramCombo);
			}
			
		}
		
		isGenerated = true;		
	}
	
	/* (non-Javadoc)
	 * @see experiment.IParameterComboGenerator#getParameterCombos()
	 */
	@Override
	public Iterable<ParameterCombo> getParameterCombos(){
		assert isGenerated : "Parameter set must be generated first!";
		return parameterCombos;
	}
	

	//A helper class to hold a pair of item and param value
	private class ItemValue {
		public int item;
		public double value;
		public ItemValue(int item, double value){
			this.item= item;
			this.value = value;
		}
	}
	
}


